attr Declarations Declaration Stmts Stmt Exprs MExpr Expr Lhss Lhs
  inh signatures :: {[(Name, TypeRef)]}

attr Module Declarations Declaration
  syn collect_signatures use {++} {[]} :: {[(Name, TypeRef)]}

attr Declarations Declaration Stmts Stmt Exprs MExpr Expr
  syn dim_callsites use {++} {[]} :: {[Declaration]}

attr Module Declarations Declaration Stmts Stmt Exprs MExpr Expr Lhss Lhs
  chn counter :: Int

sem Declaration
  | FuncDecl      lhs.collect_signatures = [(@name, @ty.self)]

sem Module
  | Mod decls.signatures = @decls.collect_signatures

sem Expr
  | ECall lhs.dim_callsites = callSiteDecl @left.self @loc.return_name @lhs.signatures ++ @exprs.dim_callsites
          loc.num :: uniqueref counter
          loc.return_name = returnName @left.self @loc.num

attr Module ModuleAttributes ModuleOptions ModuleAttribute ModuleOption Visibility FuncArgDecls FuncArgDecl FuncArgDeclField TypeRef UserTypeDeclFields UserTypeDeclField GlobalTypeDecl Declarations Declaration Lit
  syn with_initialising :: self

sem Module
  | Mod lhs.with_initialising = Mod @attributes.self
                                    @options.self
                                    (@decls.dim_callsites
                                     ++ @decls.with_initialising)

attr Stmts
  syn with_initialising use {++} {[]} :: Stmts

attr Stmt
  syn with_initialising :: Stmts

sem Stmt
  | StmtAssign     lhs.with_initialising =
     @expr.initialise_please ++ [StmtAssign @left.self @expr.with_initialising]
  | StmtDecl       lhs.with_initialising = [@self]
  | StmtReturn     lhs.with_initialising = [@self]
  | StmtSetAssign  lhs.with_initialising =
     @expr.initialise_please
       ++ [StmtSetAssign @left.self @expr.with_initialising]
  | StmtLSetAssign lhs.with_initialising =
     @expr.initialise_please
       ++ [StmtLSetAssign @left.self @expr.with_initialising]
  | StmtCall       lhs.with_initialising =
     @exprs.initialise_please
       ++ [StmtCall @left.self @exprs.with_initialising]
  | StmtIfThenElse lhs.with_initialising =
     @expr.initialise_please
       ++ [StmtIfThenElse @expr.with_initialising
                          @truestatements.with_initialising
                          @falsestatements.with_initialising]
  | StmtFor        lhs.with_initialising =
        @from.initialise_please
          ++ @to.initialise_please
          ++ @step.initialise_please
          ++ [StmtFor @counter.self
                      @from.with_initialising
                      @to.with_initialising
                      @step.with_initialising
                      @statements.with_initialising]
  | StmtDoStatementsLoopWhileCond
                   lhs.with_initialising =
     [StmtDoStatementsLoopWhileCond
        (@statements.with_initialising
         ++ @condition.initialise_please)
        @condition.self]

attr Exprs MExpr Expr
  syn initialise_please use {++} {[]} :: Stmts

attr Exprs Expr
  syn callargs_initialise_please use {++} {[]} :: Exprs

attr Exprs MExpr Expr Lhss Lhs Binop
  syn with_initialising :: self

sem Expr
  | ECall lhs.initialise_please = @exprs.initialise_please ++ @loc.set_args ++ @loc.preassign_stmt
          loc.set_args       = if isOurFunction @left.self @lhs.signatures then
                                 map (StmtAssign (NameLhs "something")) @exprs.callargs_initialise_please
                               else
                                 []
          loc.preassign_stmt = if isOurFunction @left.self @lhs.signatures then
                                 [StmtAssign (NameLhs @loc.return_name) (ECall @left.self @exprs.with_initialising)]
                               else
                                 []
  | ECall lhs.with_initialising = if isOurFunction @left.self @lhs.signatures then
                                    EVar @loc.return_name
                                  else
                                    @self

-- sem Exprs
--   | Cons lhs.callargs_initialise_please = zipWith (\num expr -> StmtAssign (NameLhs$"something" ++ show num) expr) ([1..]::[Int]) @self
--   | Nil  lhs.callargs_initialise_please = []

sem Expr
  | ECall lhs.callargs_initialise_please = [(EVar @loc.return_name)]
  | EVar  lhs.callargs_initialise_please = [@loc.with_initialising]
  | ELit  lhs.callargs_initialise_please = [@loc.with_initialising]
  | EOp   lhs.callargs_initialise_please = [@loc.with_initialising]
  | ENeg  lhs.callargs_initialise_please = [@loc.with_initialising]

{
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

isOurFunction :: Lhs -> [(Name, TypeRef)] -> Bool
isOurFunction (NameLhs nm) fs            = case lookup nm fs of
                                                        Nothing -> False
                                                        Just ty -> True
isOurFunction (FieldLhs [NameLhs nm]) fs = case lookup nm fs of
                                                        Nothing -> False
                                                        Just ty -> True
isOurFunction (FieldLhs lhss) fs    = False
isOurFunction (ArrayLhs nm idxs) fs = False

returnName :: Lhs -> Int -> Name
returnName (NameLhs nm)            num = "return_" ++ nm ++ "_" ++ show num
returnName (FieldLhs [NameLhs nm]) num = "return_" ++ nm ++ "_" ++ show num
returnName (FieldLhs lhss)         num = "" -- oops.
returnName (ArrayLhs nm idxs)      num = error "Array function call not supported"

callSiteDecl :: Lhs -> Name -> [(Name, TypeRef)] -> [Declaration]
callSiteDecl (NameLhs nm) return_name fs        =
                                         case lookup nm fs of
                                                        Nothing -> []
                                                        Just ty  -> [GlobalVarDecl Private $ GlobalTypeDecl return_name ty]
callSiteDecl (FieldLhs [NameLhs nm]) return_name fs =
                                         case lookup nm fs of
                                                        Nothing -> []
                                                        Just ty  -> [GlobalVarDecl Private $ GlobalTypeDecl return_name ty]
callSiteDecl (FieldLhs lhss) return_name fs    = []
callSiteDecl (ArrayLhs nm idxs) return_name fs = error "Array function call not supported"
}
