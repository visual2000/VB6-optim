{
import Debug.Trace
}
attr Declarations Declaration Stmts Stmt Exprs MExpr Expr Lhss Lhs
  inh signatures :: {[(Name, TypeRef)]}

attr Module Declarations Declaration
  syn collect_signatures use {++} {[]} :: {[(Name, TypeRef)]}

attr Declarations Declaration Stmts Stmt Exprs MExpr Expr
  syn dim_callsites use {++} {[]} :: {[Declaration]}

sem Declaration
  | FuncDecl      lhs.collect_signatures = [(@name, @ty.self)]

sem Module
  | Mod decls.signatures = @decls.collect_signatures

-- sem Declaration
  -- | FuncDecl statements.signatures = @lhs.collect_signatures
  -- | SubDecl  statements.signatures = @lhs.collect_signatures

sem Expr
  | ECall lhs.dim_callsites = trace (show @lhs.signatures) $ callSiteDecl @left.self @lhs.signatures
  -- | EAccess lhs.dim_callsites = [] -- TODO wrong
  -- | EOp   lhs.dim_callsites = [] -- TODO wrong
  -- | ENeg  lhs.dim_callsites = [] -- TODO wrong

{
callSiteDecl :: Lhs -> [(Name, TypeRef)] -> [Declaration]
callSiteDecl (NameLhs nm) fs            =
                                         case lookup nm fs of
                                                        Nothing -> []
                                                        Just ty  -> [GlobalVarDecl Private $ GlobalTypeDecl nm ty]
callSiteDecl (FieldLhs [NameLhs nm]) fs =
                                         case lookup nm fs of
                                                        Nothing -> []
                                                        Just ty  -> [GlobalVarDecl Private $ GlobalTypeDecl nm ty]
callSiteDecl (FieldLhs lhss) fs = []
callSiteDecl (ArrayLhs nm idxs) fs = error "Array function call not supported"
}
